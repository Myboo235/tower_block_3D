<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Three.js Block</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>
  <div>GDSC</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Create a scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);
        backgroundUrl = "https://wallpapercosmos.com/w/full/2/7/7/41442-3840x2160-desktop-4k-google-background.jpg"


        const loader = new THREE.TextureLoader();
        loader.load(backgroundUrl , function(texture)
                    {
                    scene.background = texture;  
                    });
        // Create a camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Create a renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a cube
        cube = createBlock()
        // Set up lights
        let isPlayed = false

        const stopCube = []
        // Set initial position
        // cube.position.set(-5, 0, 0);

        // Set the direction and speed of movement
        const movementSpeed = 0.03;
        // const direction = new THREE.Vector3(1, 1, 0);
        const direction = new THREE.Vector3(0.6, 0, 0);


        document.addEventListener('click', stopBlock);

        function createBlock(){
          const geometry = new THREE.BoxGeometry(0.8,0.5,0.8);
          const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
          const newCube = new THREE.Mesh(geometry, material);
          scene.add(newCube);
          newCube.position.x = -2
          newCube.rotation.set(0.6, 0, 0); 


          const wireframeGeometry = new THREE.WireframeGeometry(geometry);
          const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
          const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
          newCube.add(wireframe);

          // Ox (red), Oy (green), and Oz (blue) 
          const axesHelper = new THREE.AxesHelper(10);
          newCube.add(axesHelper);
          return newCube;
        }

        function stopBlock(){


          if(stopCube.length > 0 && Math.abs(cube.position.x - stopCube[stopCube.length - 1].position.x) > 0.8){
            isPlayed = false
            alert("GAME OVER.refresh to play again =))")
            return
          }
          if(stopCube.length > 0){
            console.log(cube.position.x - stopCube[stopCube.length - 1].position.x)

          }
          stopCube.push(cube)
          // console.log(stopCube)
          stopCube.map((c)=>{
            c.position.y-=0.5
          })
          cube = createBlock()
          
        }
        // Animation function
        const animate = () => {
          if(isPlayed){
            requestAnimationFrame(animate);

            cube.position.add(direction.clone().multiplyScalar(movementSpeed));
            // console.log(cube.position)

            // cube.position.x +=0.01
            // cube.position.y +=0.01
            
            // cube.position.z +=0.01

            
            if(cube.position.x <= -2){
              // direction.y = 1
              direction.x = 0.6

            }
            if(cube.position.x>= 2){
              // direction.y = -1
              direction.x = -0.6

            }

            // Render the scene
            renderer.render(scene, camera);
          }
            
        };

        // Run the animation
        isPlayed = true
        animate();
    </script>
</body>
</html>
